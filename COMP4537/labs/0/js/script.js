// Import messages from user.js
import {
    SUCCESS_MESSAGE,
    FAIL_MESSAGE,
    OUT_OF_RANGE_ERROR,
    PROMPT_MESSAGE,
    GO_BUTTON_MESSAGE
} from "../lang/messages/en/user.js"

const BUTTON_HEIGHT = 5
const BUTTON_WIDTH = 10
const BUTTON_PADDING_X = 1;
const BUTTON_PADDING_Y = 5;

const MAX_BUTTONS = 7
const MIN_BUTTONS = 3

/**
 * Button Class
 * Represents a single interactive button component within the game.
 * Manages its own DOM element, positioning, styling, and click events.
 *
 * (JSDoc generated by GitHub Copilot, logic and comments done by hand)
 */
class Button
{
    /**
     * Creates a new Button instance.
     * @param {number} locX - The initial horizontal position in em.
     * @param {number} locY - The initial vertical position in em.
     * @param {number} width - The width of the button in em.
     * @param {number} height - The height of the button in em.
     * @param {string} color - The CSS color string (e.g., hsl value).
     * @param {number} number - The ordinal number associated with this button.
     * @param {function} onClickHandler - Callback function to execute on click.
     */
    constructor(locX, locY, width, height, color, number, onClickHandler)
    {
        // Internal properties
        this.locX = locX;
        this.locY = locY;
        this.width = width;
        this.height = height;
        this.color = color;
        this.number = number;

        this.onClickHandler = onClickHandler;

        // Create and append the button element to the document body
        this.btn = this.drawButton();
        this.btn.addEventListener('click', () => this.onClick());
        document.body.appendChild(this.btn);
    }

    onClick()
    {
        // Callback function provided by Gemini 3 Pro
        if (this.onClickHandler)
        {
            this.onClickHandler(this.number);
        }
    }

    // creates a button element and styles it
    drawButton()
    {
        const button = document.createElement('button');
        button.type = 'button';
        button.classList.add('game-button');

        button.style.position = 'absolute';
        button.style.left = `${this.locX}em`;
        button.style.top = `${this.locY}em`;
        button.style.width = `${this.width}em`;
        button.style.height = `${this.height}em`;
        button.style.backgroundColor = this.color;
        button.innerText = this.number;
        return button;
    }

    // Sets the button's text to blank to hide the number in the sequence.
    hideButtonNumber()
    {
        this.btn.innerText = '';
        this.btn.style.cursor = 'pointer';
    }

    showButtonNumber()
    {
        this.btn.innerText = this.number;
        this.btn.style.cursor = 'default';
    }
}

/**
 * ButtonManager Class
 * Orchestrates the lifecycle of the game buttons.
 * Responsible for factory creation, layout calculation (rows/columns),
 * positioning logic (scrambling), and mass DOM updates.
 *
 * (JSDoc Generated by Gemini 3 pro, logic and comments done by hand)
 */
class ButtonManager
{
    constructor()
    {
        this.buttonArray = [];
        this.screenWidthInEm = this.getScreenWidthInEm();
        this.oneEmInPixels = this.getOneEmInPixels();
    }

    // Returns the array of Buttons
    getButtons()
    {
        return this.buttonArray;
    }

    getOneEmInPixels()
    {
        const testDiv = document.createElement('div');
        testDiv.style.width = '1em';
        testDiv.style.position = 'absolute';
        testDiv.style.visibility = 'hidden';
        document.body.appendChild(testDiv);

        const emInPixels = testDiv.getBoundingClientRect().width;
        document.body.removeChild(testDiv);

        return emInPixels;
    }

    getScreenWidthInEm()
    {
        return window.innerWidth / this.oneEmInPixels;
    }

    // creates buttons based on user input
    createButtons(clickCallback)
    {
        // check the current screen width when the go button is clicked
        this.screenWidthInEm = this.getScreenWidthInEm();

        // get number of buttons to create from input box
        const buttonCount = this.getButtonCount();

        // Do nothing if invalid
        if (buttonCount === 0)
        {
            return;
        }

        // Selects random colours for the buttons
        const colors = [];
        for (let i = 0; i < buttonCount; i++)
        {
            // Selects random colour by randomly selecting hsl values
            const color = `hsl(${Math.floor(Math.random() * 360)}, 100%, 60%)`;
            // ** 360 corresponds to the degree rotation of the hue on the color wheel
            // 100% is the saturation, and 60% is the lightness

            colors.push(color);
        }

        // Determines how many buttons can fit in a row.
        const buttonsPerRow = this.getButtonsPerRow();

        // Loops through and creates each button, moving next button to a
        // new row if it wouldn't fit within the screen width.
        for (let i = 0; i < buttonCount; i++)
        {

            // This determines the number of rows and columns needed to fit
            // all the buttons on screen, depending on the buttons per row
            const column = i % buttonsPerRow;
            const row = Math.floor(i / buttonsPerRow);

            // 1em of horizontal padding
            let locX = BUTTON_PADDING_X + (column * (BUTTON_WIDTH + 1));

            // 5 ems of vertical padding
            let locY = BUTTON_PADDING_Y + (row * (BUTTON_HEIGHT + 1));

            // Finally, create the button with all the calculated data :)
            const button = new Button(locX,
                locY,
                BUTTON_WIDTH,
                BUTTON_HEIGHT,
                colors[i],
                i + 1,
                clickCallback
            );
            // append the button to the button array.
            this.buttonArray.push(button);
        }
    }

    // Helps to determine how many buttons fit in a row based on the screen width in ems
    getButtonsPerRow()
    {
        const availableWidth = this.screenWidthInEm - BUTTON_PADDING_X; // subtract the padding I added.
        return Math.floor(availableWidth / (BUTTON_WIDTH + BUTTON_PADDING_X))
    }

    // clears all buttons from the screen and the button array
    clearButtons()
    {
        this.buttonArray = [];
        const buttons = document.querySelectorAll('.game-button');
        buttons.forEach(b => b.remove());
    }

    // Reads the input in the 'buttonCount' field and validates it
    // Returns 0 if the input is invalid
    // Else returns the number of buttons
    getButtonCount()
    {
        // default 0
        let answer = 0;
        const inputField = document.getElementById('buttonCount');
        if (inputField)
        {
            const inputValue = inputField.value;
            answer = parseInt(inputValue, 10); // Using radix 10 for decimal conversion
        }
        // Input validation, checks to ensure the amount of buttons
        // is in range.
        if (answer > MAX_BUTTONS || answer < MIN_BUTTONS)
        {
            // Gives an error if the number is out of range
            alert(OUT_OF_RANGE_ERROR);
            answer = 0;
        }
        return answer;
    }

    scrambleButtons()
    {
        // Each time the buttons are scrambled, check to make sure they will fit into the screen
        // size at that moment.
        const screenWidthInEm = window.innerWidth / this.oneEmInPixels;
        const screenHeightInEm = window.innerHeight / this.oneEmInPixels;

        for (const button of this.buttonArray)
        {
            // Set the minimum and maximum X boundaries for the button to be placed
            const minX = BUTTON_PADDING_X;
            const maxX = screenWidthInEm - BUTTON_WIDTH - BUTTON_PADDING_X;

            // Set the minimum and maximum y boundaries for the button to be placed
            const minY = BUTTON_PADDING_Y;
            const maxY = screenHeightInEm - BUTTON_HEIGHT - BUTTON_PADDING_X;

            // Handles cases where the browser window is smaller than the button
            // Places the buttons at 0 instead.
            const xRange = Math.max(0, maxX - minX);
            const yRange = Math.max(0, maxY - minY);

            // Randomly selects a new x and y coordinate based on the range provided
            const newX = Math.floor(Math.random() * xRange) + minX;
            const newY = Math.floor(Math.random() * yRange) + minY;

            // set the button to the new position using the style
            button.btn.style.left = `${newX}em`;
            button.btn.style.top = `${newY}em`;
        }
    }

    // Helper function to hide all the numbers on each button
    hideAllButtonNumbers()
    {
        for (const button of this.buttonArray)
        {
            button.hideButtonNumber();
        }
    }

    // Helper function to show all the numbers on each button
    showAllButtonNumbers()
    {
        for (const button of this.buttonArray)
        {
            button.showButtonNumber();
        }
    }
}

/**
 * GameManager Class
 * Acts as the central controller for the application logic.
 * Manages game state, user input validation, timing sequences,
 * and communication between the ButtonManager and the user.
 *
 * (JSDoc generated by Gemini 3 pro, logic and comments done by hand)
 */
class GameManager
{
    constructor()
    {
        this.acceptingUserInput = false;
        this.buttonManager = new ButtonManager();
        this.userSequence = [];
        this.timeouts = [];
    }

    // Prevents timeouts (Delays) from stacking if the user presses
    // the go button multiple times rapidly
    registerTimeout(callback, delay)
    {
        const id = setTimeout(callback, delay);
        this.timeouts.push(id);
    }

    // Clears pending timeouts (Delays) so a new round can begin
    clearPendingTimeouts()
    {
        this.timeouts.forEach(id => clearTimeout(id));
        this.timeouts = [];
    }

    // Determines if the button being pressed is the correct next
    // button in the sequence.
    handleButtonData(buttonNumber)
    {
        // If user input is currently blocked, do nothing.
        if (!this.acceptingUserInput)
        {
            return;
        }

        // Add the number of the button that was just pressed to the
        // array of numbers that the user has picked.
        this.userSequence.push(buttonNumber);

        // Since the buttons have to be clicked in 1, 2, 3.. etc order,
        // the next number is always the current length of the sequence.
        const expectedNumber = this.userSequence.length;

        // Check if the button pressed is the correct one in the sequence
        if (buttonNumber === expectedNumber)
        {
            const btnIndex = buttonNumber - 1;

            // Reveal the number that was clicked.
            this.buttonManager.getButtons()[btnIndex].showButtonNumber();

            // If this was the last button in the sequence. The user wins
            if (this.userSequence.length === this.buttonManager.getButtons().length)
            {
                // Stop accepting input, give the success popup.
                this.acceptingUserInput = false;
                setTimeout(() => alert(SUCCESS_MESSAGE), 10);
            }
        } else
        {
            // If this was the wrong choice, the user loses, and immediately all
            // the numbers are shown. Then a fail message is displayed.
            this.acceptingUserInput = false;
            this.buttonManager.showAllButtonNumbers();
            setTimeout(() => alert(FAIL_MESSAGE), 10);
        }
    }

    startNewGame()
    {
        //Clears pending timeouts (delays) when starting the new game
        this.clearPendingTimeouts();

        this.userSequence = [];
        this.buttonManager.clearButtons();

        // Callback function provided by Gemini 3 Pro
        this.buttonManager.createButtons(this.handleButtonData.bind(this));

        this.startGameSequence()
    }

    startGameSequence()
    {
        const numButtons = this.buttonManager.getButtons().length;
        const scrambleCount = numButtons;

        // The n seconds delay is equal to the number of buttons * 1000 (ms)
        const initialDelay = numButtons * 1000;

        for (let i = 0; i < numButtons; i++)
        {
            this.registerTimeout(() =>
            {
                this.buttonManager.scrambleButtons();
            }, initialDelay + (i * 1000)); // Only start scrambling after
            // the initial n seconds of delay
        }

        // Determine the total time that the scrambling will take:
        const totalTime = initialDelay + (numButtons * 1000);

        // Once the buttons have all been shuffled, hide all the numbers,
        // and allow the user to click them.
        this.registerTimeout(() =>
        {
            this.buttonManager.hideAllButtonNumbers();
            // Ready to accept guesses
            this.acceptingUserInput = true;
        }, totalTime);
    }
}

/**
 * UI Class
 * Handles the initialization of static DOM elements.
 * Ensures user-facing text is populated from the external string resources
 * to maintain separation between logic and localization.
 *
 * (JS Generated by Gemini 3 pro, logic and comments done by hand)
 */
class UI
{
    constructor()
    {
        const label = document.getElementById("promptLabel");
        if (label) label.innerText = PROMPT_MESSAGE;
        console.log(PROMPT_MESSAGE);

        const btn = document.getElementById("goButton");
        if (btn) btn.innerHTML = GO_BUTTON_MESSAGE;
        console.log(GO_BUTTON_MESSAGE);
    }
}

// Initialize the game manager
const ui = new UI();
const gameManager = new GameManager();

// Attach event listener to the start button
document.getElementById('goButton').addEventListener('click', () =>
{
    gameManager.startNewGame();
});

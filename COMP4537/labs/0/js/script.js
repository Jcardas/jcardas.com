// Import messages from user.js
import {
    SUCCESS_MESSAGE,
    FAIL_MESSAGE,
    OUT_OF_RANGE_ERROR,
    PROMPT_MESSAGE,
    GO_BUTTON_MESSAGE
} from "../lang/messages/en/user.js"

const BUTTON_HEIGHT = 5
const BUTTON_WIDTH = 10

const MAX_BUTTONS = 7
const MIN_BUTTONS = 3

/**
 * GameButton Class
 * Represents a clickable button in the game UI.
 *
 * @param {number} x - The x-coordinate of the button.
 * @param {number} y - The y-coordinate of the button.
 * @param {number} width - The width of the button.
 * @param {number} height - The height of the button.
 * @param {string} text - The text displayed on the button.
 * @param {function} onClick - The function to call when the button is clicked.
 *
 * (JSDoc generated by GitHub Copilot, logic done by hand)
 */
class Button
{
    // Constructor to initialize button properties
    constructor(locX, locY, width, height, color, number, onClickHandler)
    {
        // Internal properties
        this.locX = locX;
        this.locY = locY;
        this.width = width;
        this.height = height;
        this.color = color;
        this.number = number;

        this.onClickHandler = onClickHandler;

        // Create and append the button element to the document body
        this.btn = this.drawButton();
        this.btn.addEventListener('click', () => this.onClick());
        document.body.appendChild(this.btn);
    }

    onClick()
    {
        // Callback function provided by Gemini 3 Pro
        if (this.onClickHandler)
        {
            this.onClickHandler(this.number);
        }
    }

    // creates a button element and styles it
    drawButton()
    {
        const button = document.createElement('button');
        button.type = 'button';
        button.classList.add('game-button');

        button.style.position = 'absolute';
        button.style.left = `${this.locX}em`;
        button.style.top = `${this.locY}em`;
        button.style.width = `${this.width}em`;
        button.style.height = `${this.height}em`;
        button.style.backgroundColor = this.color;
        button.innerText = this.number;
        return button;
    }

    // Sets the button's text to blank to hide the number in the sequence.
    hideButtonNumber()
    {
        this.btn.innerText = '';
        this.btn.style.cursor = 'pointer';
    }

    showButtonNumber()
    {
        this.btn.innerText = this.number;
        this.btn.style.cursor = 'default';
    }
}

/**
 * ButtonManager Class
 * Manages the creation, layout, and behavior of game buttons.
 */
class ButtonManager
{
    constructor()
    {
        this.buttonArray = [];
        this.screenWidthInEm = this.getScreenWidthInEm();
    }

    // Returns the array of Buttons
    getButtons()
    {
        return this.buttonArray;
    }

    getOneEmInPixels()
    {
        const testDiv = document.createElement('div');
        testDiv.style.width = '1em';
        testDiv.style.position = 'absolute';
        testDiv.style.visibility = 'hidden';
        document.body.appendChild(testDiv);

        const emInPixels = testDiv.getBoundingClientRect().width;
        document.body.removeChild(testDiv);

        return emInPixels;
    }

    getScreenWidthInEm()
    {
        return window.innerWidth / this.getOneEmInPixels();
    }

    // creates buttons based on user input
    createButtons(clickCallback)
    {
        this.screenWidthInEm = this.getScreenWidthInEm();
        console.log("Screen width in em:", this.screenWidthInEm);

        const buttonCount = this.getButtonCount();
        if (buttonCount === 0)
        {
            return;
        }

        // Selects random colours for the buttons
        const colors = [];
        for (let i = 0; i < buttonCount; i++)
        {
            const color = `hsl(${Math.floor(Math.random() * 360)}, 100%, 60%)`;
            colors.push(color);
        }

        const buttonsPerRow = this.getButtonsPerRow();

        for (let i = 0; i < buttonCount; i++)
        {
            const column = i % buttonsPerRow;
            const row = Math.floor(i / buttonsPerRow);

            let locX = 1 + (column * (BUTTON_WIDTH + 1));
            let locY = 5 + (row * (BUTTON_HEIGHT + 1));

            const button = new Button(locX,
                locY,
                BUTTON_WIDTH,
                BUTTON_HEIGHT,
                colors[i],
                i + 1,
                clickCallback
            );
            this.buttonArray.push(button);
        }
    }

    // Helps to determine how many buttons fit in a row
    getButtonsPerRow()
    {
        const availableWidth = this.screenWidthInEm - 1; // subtract the padding I added.
        return Math.floor(availableWidth / (BUTTON_WIDTH + 1))
    }

    // clears all buttons from the screen and the button array
    clearButtons()
    {
        this.buttonArray = [];
        const buttons = document.querySelectorAll('.game-button');
        buttons.forEach(b => b.remove());
    }

    // Reads the input in the 'buttonCount' field and validates it
    // Returns 0 if the input is invalid
    // Else returns the number of buttons
    getButtonCount()
    {
        let answer = 0;
        const inputField = document.getElementById('buttonCount');
        if (inputField)
        {
            const inputValue = inputField.value;
            answer = parseInt(inputValue, 10); // Using radix 10 for decimal conversion
        }
        if (answer > MAX_BUTTONS || answer < MIN_BUTTONS)
        {
            // Gives an error if the number is out of range
            alert(OUT_OF_RANGE_ERROR);
            answer = 0;
        }
        return answer;
    }

    scrambleButtons()
    {
        const emInPixels = this.getOneEmInPixels();

        const screenWidthInEm = window.innerWidth / emInPixels;
        const screenHeightInEm = window.innerHeight / emInPixels;

        for (const button of this.buttonArray)
        {
            const minX = 1;
            const maxX = screenWidthInEm - BUTTON_WIDTH - 1;

            const minY = 5;
            const maxY = screenHeightInEm - BUTTON_HEIGHT - 1;

            const xRange = Math.max(0, maxX - minX);
            const yRange = Math.max(0, maxY - minY);

            const newX = Math.floor(Math.random() * xRange) + minX;
            const newY = Math.floor(Math.random() * yRange) + minY;

            button.btn.style.left = `${newX}em`;
            button.btn.style.top = `${newY}em`;
        }
    }

    hideAllButtonNumbers()
    {
        for (const button of this.buttonArray)
        {
            button.hideButtonNumber();
        }
    }

    showAllButtonNumbers()
    {
        for (const button of this.buttonArray)
        {
            button.showButtonNumber();
        }
    }
}

class GameManager
{
    constructor()
    {
        this.acceptingUserInput = false;
        this.buttonManager = new ButtonManager();
        this.userSequence = [];
    }

    handleButtonData(buttonNumber)
    {
        if (!this.acceptingUserInput)
        {
            return;
        }

        this.userSequence.push(buttonNumber);

        const expectedNumber = this.userSequence.length;

        // Check if the button pressed is the correct one in the sequence
        if (buttonNumber === expectedNumber)
        {
            const btnIndex = buttonNumber - 1;
            this.buttonManager.getButtons()[btnIndex].showButtonNumber();

            if (this.userSequence.length === this.buttonManager.getButtons().length)
            {
                this.acceptingUserInput = false;
                setTimeout(() => alert(SUCCESS_MESSAGE), 10);
            }
        } else
        {
            this.acceptingUserInput = false;
            this.buttonManager.showAllButtonNumbers();
            setTimeout(() => alert(FAIL_MESSAGE), 10);
        }
    }

    startNewGame()
    {
        this.userSequence = [];
        this.buttonManager.clearButtons();

        // Callback function provided by Gemini 3 Pro
        this.buttonManager.createButtons(this.handleButtonData.bind(this));

        this.startGameSequence()
    }

    startGameSequence()
    {
        const numButtons = this.buttonManager.getButtons().length;
        const scrambleCount = numButtons;

        // The n seconds delay is equal to the number of buttons * 1000 (ms)
        const initialDelay = numButtons * 1000;

        for (let i = 0; i < numButtons; i++)
        {
            setTimeout(() =>
            {
                this.buttonManager.scrambleButtons();
            }, initialDelay + (i * 2000)); // Only start scrambling after
            // the initial n seconds of delay
        }

        // Determine the total time that the scrambling will take:
        const totalTime = initialDelay + (numButtons * 2000);

        setTimeout(() =>
        {
            this.buttonManager.hideAllButtonNumbers();
            // Ready to accept guesses
            this.acceptingUserInput = true;
        }, totalTime);
    }
}

/**
 * UI Class
 * Responsible for initializing and managing static user interface elements.
 * It populates the prompt labels and button text using imported string constants
 * to ensure no hard-coded strings appear in the logic.
 *
 * (JS Generated by Gemini 3 pro)
 */
class UI
{
    constructor()
    {
        const label = document.getElementById("promptLabel");
        if (label) label.innerText = PROMPT_MESSAGE;
        console.log(PROMPT_MESSAGE);

        const btn = document.getElementById("goButton");
        if (btn) btn.innerHTML = GO_BUTTON_MESSAGE;
        console.log(GO_BUTTON_MESSAGE);
    }
}

// Initialize the game manager
const ui = new UI();
const gameManager = new GameManager();

// Attach event listener to the start button
document.getElementById('goButton').addEventListener('click', () =>
{
    gameManager.startNewGame();
});
